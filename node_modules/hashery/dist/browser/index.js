var S=Object.defineProperty;var A=(u,e,r)=>e in u?S(u,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):u[e]=r;var h=(u,e,r)=>A(u,typeof e!="symbol"?e+"":e,r);import{Hookified as w}from"hookified";var d=class{constructor(e){h(this,"_enabled",!0);h(this,"_maxSize",4e3);h(this,"_store",new Map);h(this,"_keys",[]);e?.enabled!==void 0&&(this._enabled=e.enabled),e?.maxSize!==void 0&&(this._maxSize=e.maxSize)}get enabled(){return this._enabled}set enabled(e){this._enabled=e}get maxSize(){return this._maxSize}set maxSize(e){this._maxSize=e}get store(){return this._store}get size(){return this._store.size}get(e){return this._store.get(e)}set(e,r){if(this._enabled){if(this._store.has(e)){this._store.set(e,r);return}if(this._store.size>=this._maxSize){let i=this._keys.shift();i&&this._store.delete(i)}this._keys.push(e),this._store.set(e,r)}}has(e){return this._store.has(e)}clear(){this._store.clear(),this._keys=[]}};var y=class{get name(){return"crc32"}toHashSync(e){let r;if(e instanceof Uint8Array)r=e;else if(e instanceof ArrayBuffer)r=new Uint8Array(e);else if(e instanceof DataView)r=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);else{let o=e;r=new Uint8Array(o.buffer,o.byteOffset,o.byteLength)}let i=3988292384,t=4294967295;for(let o=0;o<r.length;o++){t=t^r[o];for(let s=0;s<8;s++)t=t>>>1^i&-(t&1)}return t=(t^4294967295)>>>0,t.toString(16).padStart(8,"0")}async toHash(e){return this.toHashSync(e)}};var p=class{constructor(e){h(this,"_algorithm","SHA-256");e?.algorithm&&(this._algorithm=e?.algorithm)}get name(){return this._algorithm}async toHash(e){let r=await crypto.subtle.digest(this._algorithm,e);return Array.from(new Uint8Array(r)).map(n=>n.toString(16).padStart(2,"0")).join("")}};var b=class{get name(){return"djb2"}toHashSync(e){let r;if(e instanceof Uint8Array)r=e;else if(e instanceof ArrayBuffer)r=new Uint8Array(e);else if(e instanceof DataView)r=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);else{let n=e;r=new Uint8Array(n.buffer,n.byteOffset,n.byteLength)}let i=5381;for(let n=0;n<r.length;n++)i=(i<<5)+i+r[n],i=i>>>0;return i.toString(16).padStart(8,"0")}async toHash(e){return this.toHashSync(e)}};var _=class{get name(){return"fnv1"}toHashSync(e){let r;if(e instanceof Uint8Array)r=e;else if(e instanceof ArrayBuffer)r=new Uint8Array(e);else if(e instanceof DataView)r=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);else{let s=e;r=new Uint8Array(s.buffer,s.byteOffset,s.byteLength)}let i=2166136261,t=16777619,n=i;for(let s=0;s<r.length;s++)n=n*t,n=n^r[s],n=n>>>0;return n.toString(16).padStart(8,"0")}async toHash(e){return this.toHashSync(e)}};var H=class{constructor(e=0){h(this,"_seed");this._seed=e>>>0}get name(){return"murmer"}get seed(){return this._seed}toHashSync(e){let r;if(e instanceof Uint8Array)r=e;else if(e instanceof ArrayBuffer)r=new Uint8Array(e);else if(e instanceof DataView)r=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);else{let c=e;r=new Uint8Array(c.buffer,c.byteOffset,c.byteLength)}let i=3432918353,t=461845907,n=r.length,o=Math.floor(n/4),s=this._seed;for(let c=0;c<o;c++){let l=c*4,g=r[l]&255|(r[l+1]&255)<<8|(r[l+2]&255)<<16|(r[l+3]&255)<<24;g=this._imul(g,i),g=this._rotl32(g,15),g=this._imul(g,t),s^=g,s=this._rotl32(s,13),s=this._imul(s,5)+3864292196}let m=o*4,a=0;switch(n&3){case 3:a^=(r[m+2]&255)<<16;case 2:a^=(r[m+1]&255)<<8;case 1:a^=r[m]&255,a=this._imul(a,i),a=this._rotl32(a,15),a=this._imul(a,t),s^=a}return s^=n,s^=s>>>16,s=this._imul(s,2246822507),s^=s>>>13,s=this._imul(s,3266489909),s^=s>>>16,s=s>>>0,s.toString(16).padStart(8,"0")}async toHash(e){return this.toHashSync(e)}_imul(e,r){if(Math.imul)return Math.imul(e,r);let i=e>>>16&65535;let t=e&65535;let n=r>>>16&65535;let o=r&65535;return t*o+(i*o+t*n<<16>>>0)|0}_rotl32(e,r){return e<<r|e>>>32-r}};var v=class{constructor(e){h(this,"_providers",new Map);h(this,"_getFuzzy",!0);e?.providers&&this.loadProviders(e?.providers),e?.getFuzzy!==void 0&&(this._getFuzzy=!!e?.getFuzzy)}loadProviders(e){for(let r of e)this._providers.set(r.name,r)}get providers(){return this._providers}set providers(e){this._providers=e}get names(){return Array.from(this._providers.keys())}get(e,r){let i=r?.fuzzy??this._getFuzzy;e=e.trim();let t=this._providers.get(e);return t===void 0&&i===!0&&(e=e.toLowerCase(),t=this._providers.get(e)),t===void 0&&i===!0&&(e=e.replaceAll("-",""),t=this._providers.get(e)),t}add(e){this._providers.set(e.name,e)}remove(e){return this._providers.delete(e)}};var x=class extends w{constructor(r){super(r);h(this,"_parse",JSON.parse);h(this,"_stringify",JSON.stringify);h(this,"_providers",new v);h(this,"_defaultAlgorithm","SHA-256");h(this,"_defaultAlgorithmSync","djb2");h(this,"_cache");r?.parse&&(this._parse=r.parse),r?.stringify&&(this._stringify=r.stringify),r?.defaultAlgorithm&&(this._defaultAlgorithm=r.defaultAlgorithm),r?.defaultAlgorithmSync&&(this._defaultAlgorithmSync=r.defaultAlgorithmSync),this._cache=new d(r?.cache),this.loadProviders(r?.providers,{includeBase:r?.includeBase??!0})}get parse(){return this._parse}set parse(r){this._parse=r}get stringify(){return this._stringify}set stringify(r){this._stringify=r}get providers(){return this._providers}set providers(r){this._providers=r}get names(){return this._providers.names}get defaultAlgorithm(){return this._defaultAlgorithm}set defaultAlgorithm(r){this._defaultAlgorithm=r}get defaultAlgorithmSync(){return this._defaultAlgorithmSync}set defaultAlgorithmSync(r){this._defaultAlgorithmSync=r}get cache(){return this._cache}async toHash(r,i){let t={data:r,algorithm:i?.algorithm??this._defaultAlgorithm,maxLength:i?.maxLength};await this.beforeHook("toHash",t);let n=this._stringify(t.data),o=`${t.algorithm}:${n}`;if(this._cache.enabled){let l=this._cache.get(o);if(l!==void 0)return i?.maxLength&&l.length>i.maxLength?l.substring(0,i.maxLength):l}let m=new TextEncoder().encode(n),a=this._providers.get(t.algorithm);a||(a=new p({algorithm:this._defaultAlgorithm}));let f=await a.toHash(m);this._cache.enabled&&this._cache.set(o,f),i?.maxLength&&f.length>i?.maxLength&&(f=f.substring(0,i.maxLength));let c={hash:f,data:t.data,algorithm:t.algorithm};return await this.afterHook("toHash",c),c.hash}async toNumber(r,i={}){let{min:t=0,max:n=100,algorithm:o=this._defaultAlgorithm,hashLength:s=16}=i;if(t>n)throw new Error("min cannot be greater than max");let m=await this.toHash(r,{algorithm:o,maxLength:s}),a=Number.parseInt(m,16),f=n-t+1;return t+a%f}toHashSync(r,i){let t={data:r,algorithm:i?.algorithm??this._defaultAlgorithmSync,maxLength:i?.maxLength};this.beforeHook("toHashSync",t);let n=t.algorithm,o=this._stringify(t.data),s=`${n}:${o}`;if(this._cache.enabled){let g=this._cache.get(s);if(g!==void 0)return i?.maxLength&&g.length>i.maxLength?g.substring(0,i.maxLength):g}let a=new TextEncoder().encode(o),f=this._providers.get(n);if(!f)throw new Error(`Hash provider '${n}' not found`);if(!f.toHashSync)throw new Error(`Hash provider '${n}' does not support synchronous hashing. Use toHash() instead or choose a different algorithm (djb2, fnv1, murmer, crc32).`);let c=f.toHashSync(a);this._cache.enabled&&this._cache.set(s,c),i?.maxLength&&c.length>i?.maxLength&&(c=c.substring(0,i.maxLength));let l={hash:c,data:t.data,algorithm:t.algorithm};return this.afterHook("toHashSync",l),l.hash}toNumberSync(r,i={}){let{min:t=0,max:n=100,algorithm:o=this._defaultAlgorithmSync,hashLength:s=16}=i;if(t>n)throw new Error("min cannot be greater than max");let m=this.toHashSync(r,{algorithm:o,maxLength:s}),a=Number.parseInt(m,16),f=n-t+1;return t+a%f}loadProviders(r,i={includeBase:!0}){if(r)for(let t of r)this._providers.add(t);i.includeBase&&(this.providers.add(new p({algorithm:"SHA-256"})),this.providers.add(new p({algorithm:"SHA-384"})),this.providers.add(new p({algorithm:"SHA-512"})),this.providers.add(new y),this.providers.add(new b),this.providers.add(new _),this.providers.add(new H))}};export{d as Cache,x as Hashery};
/* v8 ignore next -- @preserve */
//# sourceMappingURL=index.js.map