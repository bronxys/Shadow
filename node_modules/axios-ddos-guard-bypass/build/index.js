"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ddosGuardBypass = void 0;
const tough_cookie_1 = require("tough-cookie");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
function parseCookies(headers) {
    let cookies = [];
    if (Array.isArray(headers['set-cookie'])) {
        cookies = headers['set-cookie'];
    }
    else if (headers['set-cookie']) {
        cookies = [headers['set-cookie']];
    }
    return cookies;
}
async function addCookiesToJar(cookies, jar, url) {
    for (const cookie of cookies) {
        await jar.setCookie(cookie, url);
    }
}
async function parseAndAddCookiesToJar(axios, response) {
    if ((response === null || response === void 0 ? void 0 : response.headers) && response.headers['set-cookie']) {
        const config = response.config;
        return addCookiesToJar(parseCookies(response.headers), config.jar, axios.getUri(response.config));
    }
}
function ddosGuardBypass(axios) {
    axios.interceptors.request.use(async (config) => {
        if (config.jar) {
            // Get cookies valid for request and add them to headers, preserving exisiting cookies
            let existingCookies = config.headers['cookie'] || '';
            let newCookies = config.jar.getCookieStringSync(axios.getUri(config));
            if (newCookies) {
                config.headers['cookie'] =
                    existingCookies + (existingCookies ? '; ' : '') + newCookies;
            }
        }
        else {
            // Create new CookieJar instance if none provided
            config.jar = new tough_cookie_1.CookieJar();
        }
        return config;
    }, (error) => {
        return Promise.reject(error);
    });
    axios.interceptors.response.use(async (response) => {
        if (response.config.jar) {
            await parseAndAddCookiesToJar(axios, response);
        }
        return response;
    }, async (error) => {
        var _a, _b, _c;
        if (error.config.jar) {
            await parseAndAddCookiesToJar(axios, error.response);
        }
        const status = (_a = error.response) === null || _a === void 0 ? void 0 : _a.status;
        // Determine if the site is protected by DDoS Guard and our request got denied (403)
        if (status === 403 && ((_c = (_b = error.response) === null || _b === void 0 ? void 0 : _b.headers) === null || _c === void 0 ? void 0 : _c.server) === 'ddos-guard') {
            let origin = new URL(error.config.url).origin;
            // The site is protected, we try to bypass
            let guardCheckUrl = `${origin}/.well-known/ddos-guard/check?context=free_splash`;
            let resp = await axios({
                url: guardCheckUrl,
                headers: {
                    'User-Agent': error.config.headers['user-agent']
                },
                proxy: error.config.proxy
            });
            // Send a request with fake mark data
            let markUrl = `${origin}/.well-known/ddos-guard/mark/`;
            let mark = JSON.stringify(JSON.parse(fs_1.default
                .readFileSync(path_1.default.resolve(__dirname, `../src/fakeMark.json`))
                .toString()));
            resp = await axios({
                method: 'POST',
                url: markUrl,
                data: mark,
                headers: {
                    'User-Agent': error.config.headers['user-agent']
                },
                proxy: error.config.proxy
            });
            // Determine if we can reply the request
            // If will fail if some stream-like data was provided, so we only allow reply if we have buffer
            if (error.config.data && !(error.config.data instanceof Buffer)) {
                throw new Error('Cannot reply request with non-buffer data');
            }
            // Reply the request
            return axios(error.config);
        }
        else {
            return Promise.reject(error);
        }
    });
}
exports.ddosGuardBypass = ddosGuardBypass;
//# sourceMappingURL=index.js.map